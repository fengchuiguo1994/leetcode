# leetcode
the python/C code to solve the leetcode problem

### 1.两数之和
利用字典记录该列表的元素和位置,然后判断 target-当前元素 存不存在就行,所以至多遍历一次就行,时间复杂度O(n),空间复杂度:列表本身T(n),转成字典2T(n),合计3T(n)即T(n)。<br/>

### 2.两数相加
利用链表实现多位数的相加,难点是控制不等长的链表,然后需要记得进位。时间复杂度是max{O(N),O(M))。所以是O(N)

### 3. 无重复字符的最长子串
难点,怎么去找到最长的子串,第一种是暴力搜索(不用想了,没通过)。换种思路,我们遍历字符串,每次逐一加一个字符到substring中,然后判断有没有重复的,如果有,记录下当前字串长度,然后就从头开始剔除到这个字符的位置的字符串,然后重复上面的工作。[参考](http://www.luyixian.cn/news_show_11941.aspx)

### 4. 寻找两个有序数组的中位数
难点:首先要确定中位数是分奇数个和偶数个的,然后用多路归并(两路归并)的算法将两个列表有序整合起来,在对应的位置上获取中位数。

### 5. 最长回文子串
难点:回文分两种,一种是奇数个的回文,还有一个是偶数个的回文。